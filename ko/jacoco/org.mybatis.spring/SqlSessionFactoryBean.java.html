<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlSessionFactoryBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis-spring</a> &gt; <a href="index.source.html" class="el_package">org.mybatis.spring</a> &gt; <span class="el_source">SqlSessionFactoryBean.java</span></div><h1>SqlSessionFactoryBean.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2010-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.mybatis.spring;

import static org.springframework.util.Assert.notNull;
import static org.springframework.util.Assert.state;
import static org.springframework.util.ObjectUtils.isEmpty;
import static org.springframework.util.StringUtils.hasLength;
import static org.springframework.util.StringUtils.tokenizeToStringArray;

import java.io.IOException;
import java.lang.reflect.Modifier;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.function.IntFunction;
import java.util.stream.Stream;

import javax.sql.DataSource;

import org.apache.ibatis.builder.xml.XMLConfigBuilder;
import org.apache.ibatis.builder.xml.XMLMapperBuilder;
import org.apache.ibatis.cache.Cache;
import org.apache.ibatis.executor.ErrorContext;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.io.VFS;
import org.apache.ibatis.mapping.DatabaseIdProvider;
import org.apache.ibatis.mapping.Environment;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.reflection.factory.ObjectFactory;
import org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.apache.ibatis.transaction.TransactionFactory;
import org.apache.ibatis.type.TypeHandler;
import org.mybatis.logging.Logger;
import org.mybatis.logging.LoggerFactory;
import org.mybatis.spring.transaction.SpringManagedTransactionFactory;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy;
import org.springframework.util.ClassUtils;

/**
 * {@code FactoryBean} that creates a MyBatis {@code SqlSessionFactory}. This is the usual way to set up a shared
 * MyBatis {@code SqlSessionFactory} in a Spring application context; the SqlSessionFactory can then be passed to
 * MyBatis-based DAOs via dependency injection.
 * &lt;p&gt;
 * Either {@code DataSourceTransactionManager} or {@code JtaTransactionManager} can be used for transaction demarcation
 * in combination with a {@code SqlSessionFactory}. JTA should be used for transactions which span multiple databases or
 * when container managed transactions (CMT) are being used.
 *
 * @author Putthiphong Boonphong
 * @author Hunter Presnall
 * @author Eduardo Macarron
 * @author Eddú Meléndez
 * @author Kazuki Shimizu
 * @author Jens Schauder
 *
 * @see #setConfigLocation
 * @see #setDataSource
 */
<span class="fc" id="L91">public class SqlSessionFactoryBean</span>
    implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ContextRefreshedEvent&gt; {

<span class="fc" id="L94">  private static final Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean.class);</span>

<span class="fc" id="L96">  private static final ResourcePatternResolver RESOURCE_PATTERN_RESOLVER = new PathMatchingResourcePatternResolver();</span>
<span class="fc" id="L97">  private static final MetadataReaderFactory METADATA_READER_FACTORY = new CachingMetadataReaderFactory();</span>

  private Resource configLocation;

  private Configuration configuration;

  private Resource[] mapperLocations;

  private DataSource dataSource;

  private TransactionFactory transactionFactory;

  private Properties configurationProperties;

<span class="fc" id="L111">  private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span>

  private SqlSessionFactory sqlSessionFactory;

  // EnvironmentAware requires spring 3.1
<span class="fc" id="L116">  private String environment = SqlSessionFactoryBean.class.getSimpleName();</span>

  private boolean failFast;

  private Interceptor[] plugins;

  private TypeHandler&lt;?&gt;[] typeHandlers;

  private String typeHandlersPackage;

  @SuppressWarnings(&quot;rawtypes&quot;)
  private Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler;

  private Class&lt;?&gt;[] typeAliases;

  private String typeAliasesPackage;

  private Class&lt;?&gt; typeAliasesSuperType;

  private LanguageDriver[] scriptingLanguageDrivers;

  private Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver;

  // issue #19. No default provider.
  private DatabaseIdProvider databaseIdProvider;

  private Class&lt;? extends VFS&gt; vfs;

  private Cache cache;

  private ObjectFactory objectFactory;

  private ObjectWrapperFactory objectWrapperFactory;

  /**
   * Sets the ObjectFactory.
   *
   * @since 1.1.2
   *
   * @param objectFactory
   *          a custom ObjectFactory
   */
  public void setObjectFactory(ObjectFactory objectFactory) {
<span class="fc" id="L159">    this.objectFactory = objectFactory;</span>
<span class="fc" id="L160">  }</span>

  /**
   * Sets the ObjectWrapperFactory.
   *
   * @since 1.1.2
   *
   * @param objectWrapperFactory
   *          a specified ObjectWrapperFactory
   */
  public void setObjectWrapperFactory(ObjectWrapperFactory objectWrapperFactory) {
<span class="fc" id="L171">    this.objectWrapperFactory = objectWrapperFactory;</span>
<span class="fc" id="L172">  }</span>

  /**
   * Gets the DatabaseIdProvider
   *
   * @since 1.1.0
   *
   * @return a specified DatabaseIdProvider
   */
  public DatabaseIdProvider getDatabaseIdProvider() {
<span class="nc" id="L182">    return databaseIdProvider;</span>
  }

  /**
   * Sets the DatabaseIdProvider. As of version 1.2.2 this variable is not initialized by default.
   *
   * @since 1.1.0
   *
   * @param databaseIdProvider
   *          a DatabaseIdProvider
   */
  public void setDatabaseIdProvider(DatabaseIdProvider databaseIdProvider) {
<span class="fc" id="L194">    this.databaseIdProvider = databaseIdProvider;</span>
<span class="fc" id="L195">  }</span>

  /**
   * Gets the VFS.
   *
   * @return a specified VFS
   */
  public Class&lt;? extends VFS&gt; getVfs() {
<span class="nc" id="L203">    return this.vfs;</span>
  }

  /**
   * Sets the VFS.
   *
   * @param vfs
   *          a VFS
   */
  public void setVfs(Class&lt;? extends VFS&gt; vfs) {
<span class="nc" id="L213">    this.vfs = vfs;</span>
<span class="nc" id="L214">  }</span>

  /**
   * Gets the Cache.
   *
   * @return a specified Cache
   */
  public Cache getCache() {
<span class="fc" id="L222">    return this.cache;</span>
  }

  /**
   * Sets the Cache.
   *
   * @param cache
   *          a Cache
   */
  public void setCache(Cache cache) {
<span class="fc" id="L232">    this.cache = cache;</span>
<span class="fc" id="L233">  }</span>

  /**
   * Mybatis plugin list.
   *
   * @since 1.0.1
   *
   * @param plugins
   *          list of plugins
   */
  public void setPlugins(Interceptor... plugins) {
<span class="fc" id="L244">    this.plugins = plugins;</span>
<span class="fc" id="L245">  }</span>

  /**
   * Packages to search for type aliases.
   * &lt;p&gt;
   * Since 2.0.1, allow to specify a wildcard such as {@code com.example.*.model}.
   *
   * @since 1.0.1
   *
   * @param typeAliasesPackage
   *          package to scan for domain objects
   */
  public void setTypeAliasesPackage(String typeAliasesPackage) {
<span class="fc" id="L258">    this.typeAliasesPackage = typeAliasesPackage;</span>
<span class="fc" id="L259">  }</span>

  /**
   * Super class which domain objects have to extend to have a type alias created. No effect if there is no package to
   * scan configured.
   *
   * @since 1.1.2
   *
   * @param typeAliasesSuperType
   *          super class for domain objects
   */
  public void setTypeAliasesSuperType(Class&lt;?&gt; typeAliasesSuperType) {
<span class="fc" id="L271">    this.typeAliasesSuperType = typeAliasesSuperType;</span>
<span class="fc" id="L272">  }</span>

  /**
   * Packages to search for type handlers.
   * &lt;p&gt;
   * Since 2.0.1, allow to specify a wildcard such as {@code com.example.*.typehandler}.
   *
   * @since 1.0.1
   *
   * @param typeHandlersPackage
   *          package to scan for type handlers
   */
  public void setTypeHandlersPackage(String typeHandlersPackage) {
<span class="fc" id="L285">    this.typeHandlersPackage = typeHandlersPackage;</span>
<span class="fc" id="L286">  }</span>

  /**
   * Set type handlers. They must be annotated with {@code MappedTypes} and optionally with {@code MappedJdbcTypes}
   *
   * @since 1.0.1
   *
   * @param typeHandlers
   *          Type handler list
   */
  public void setTypeHandlers(TypeHandler&lt;?&gt;... typeHandlers) {
<span class="fc" id="L297">    this.typeHandlers = typeHandlers;</span>
<span class="fc" id="L298">  }</span>

  /**
   * Set the default type handler class for enum.
   *
   * @since 2.0.5
   *
   * @param defaultEnumTypeHandler
   *          The default type handler class for enum
   */
  public void setDefaultEnumTypeHandler(
      @SuppressWarnings(&quot;rawtypes&quot;) Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler) {
<span class="fc" id="L310">    this.defaultEnumTypeHandler = defaultEnumTypeHandler;</span>
<span class="fc" id="L311">  }</span>

  /**
   * List of type aliases to register. They can be annotated with {@code Alias}
   *
   * @since 1.0.1
   *
   * @param typeAliases
   *          Type aliases list
   */
  public void setTypeAliases(Class&lt;?&gt;... typeAliases) {
<span class="fc" id="L322">    this.typeAliases = typeAliases;</span>
<span class="fc" id="L323">  }</span>

  /**
   * If true, a final check is done on Configuration to assure that all mapped statements are fully loaded and there is
   * no one still pending to resolve includes. Defaults to false.
   *
   * @since 1.0.1
   *
   * @param failFast
   *          enable failFast
   */
  public void setFailFast(boolean failFast) {
<span class="nc" id="L335">    this.failFast = failFast;</span>
<span class="nc" id="L336">  }</span>

  /**
   * Set the location of the MyBatis {@code SqlSessionFactory} config file. A typical value is
   * &quot;WEB-INF/mybatis-configuration.xml&quot;.
   *
   * @param configLocation
   *          a location the MyBatis config file
   */
  public void setConfigLocation(Resource configLocation) {
<span class="fc" id="L346">    this.configLocation = configLocation;</span>
<span class="fc" id="L347">  }</span>

  /**
   * Set a customized MyBatis configuration.
   *
   * @param configuration
   *          MyBatis configuration
   *
   * @since 1.3.0
   */
  public void setConfiguration(Configuration configuration) {
<span class="fc" id="L358">    this.configuration = configuration;</span>
<span class="fc" id="L359">  }</span>

  /**
   * Set locations of MyBatis mapper files that are going to be merged into the {@code SqlSessionFactory} configuration
   * at runtime.
   * &lt;p&gt;
   * This is an alternative to specifying &quot;&amp;lt;sqlmapper&amp;gt;&quot; entries in an MyBatis config file. This property being
   * based on Spring's resource abstraction also allows for specifying resource patterns here: e.g.
   * &quot;classpath*:sqlmap/*-mapper.xml&quot;.
   *
   * @param mapperLocations
   *          location of MyBatis mapper files
   */
  public void setMapperLocations(Resource... mapperLocations) {
<span class="fc" id="L373">    this.mapperLocations = mapperLocations;</span>
<span class="fc" id="L374">  }</span>

  /**
   * Set optional properties to be passed into the SqlSession configuration, as alternative to a
   * {@code &amp;lt;properties&amp;gt;} tag in the configuration xml file. This will be used to resolve placeholders in the
   * config file.
   *
   * @param sqlSessionFactoryProperties
   *          optional properties for the SqlSessionFactory
   */
  public void setConfigurationProperties(Properties sqlSessionFactoryProperties) {
<span class="fc" id="L385">    this.configurationProperties = sqlSessionFactoryProperties;</span>
<span class="fc" id="L386">  }</span>

  /**
   * Set the JDBC {@code DataSource} that this instance should manage transactions for. The {@code DataSource} should
   * match the one used by the {@code SqlSessionFactory}: for example, you could specify the same JNDI DataSource for
   * both.
   * &lt;p&gt;
   * A transactional JDBC {@code Connection} for this {@code DataSource} will be provided to application code accessing
   * this {@code DataSource} directly via {@code DataSourceUtils} or {@code DataSourceTransactionManager}.
   * &lt;p&gt;
   * The {@code DataSource} specified here should be the target {@code DataSource} to manage transactions for, not a
   * {@code TransactionAwareDataSourceProxy}. Only data access code may work with
   * {@code TransactionAwareDataSourceProxy}, while the transaction manager needs to work on the underlying target
   * {@code DataSource}. If there's nevertheless a {@code TransactionAwareDataSourceProxy} passed in, it will be
   * unwrapped to extract its target {@code DataSource}.
   *
   * @param dataSource
   *          a JDBC {@code DataSource}
   */
  public void setDataSource(DataSource dataSource) {
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">    if (dataSource instanceof TransactionAwareDataSourceProxy) {</span>
      // If we got a TransactionAwareDataSourceProxy, we need to perform
      // transactions for its underlying target DataSource, else data
      // access code won't see properly exposed transactions (i.e.
      // transactions for the target DataSource).
<span class="nc" id="L411">      this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource();</span>
    } else {
<span class="fc" id="L413">      this.dataSource = dataSource;</span>
    }
<span class="fc" id="L415">  }</span>

  /**
   * Sets the {@code SqlSessionFactoryBuilder} to use when creating the {@code SqlSessionFactory}.
   * &lt;p&gt;
   * This is mainly meant for testing so that mock SqlSessionFactory classes can be injected. By default,
   * {@code SqlSessionFactoryBuilder} creates {@code DefaultSqlSessionFactory} instances.
   *
   * @param sqlSessionFactoryBuilder
   *          a SqlSessionFactoryBuilder
   */
  public void setSqlSessionFactoryBuilder(SqlSessionFactoryBuilder sqlSessionFactoryBuilder) {
<span class="fc" id="L427">    this.sqlSessionFactoryBuilder = sqlSessionFactoryBuilder;</span>
<span class="fc" id="L428">  }</span>

  /**
   * Set the MyBatis TransactionFactory to use. Default is {@code SpringManagedTransactionFactory}.
   * &lt;p&gt;
   * The default {@code SpringManagedTransactionFactory} should be appropriate for all cases: be it Spring transaction
   * management, EJB CMT or plain JTA. If there is no active transaction, SqlSession operations will execute SQL
   * statements non-transactionally.
   * &lt;p&gt;
   * &lt;b&gt;It is strongly recommended to use the default {@code TransactionFactory}.&lt;/b&gt; If not used, any attempt at
   * getting an SqlSession through Spring's MyBatis framework will throw an exception if a transaction is active.
   *
   * @see SpringManagedTransactionFactory
   *
   * @param transactionFactory
   *          the MyBatis TransactionFactory
   */
  public void setTransactionFactory(TransactionFactory transactionFactory) {
<span class="fc" id="L446">    this.transactionFactory = transactionFactory;</span>
<span class="fc" id="L447">  }</span>

  /**
   * &lt;b&gt;NOTE:&lt;/b&gt; This class &lt;em&gt;overrides&lt;/em&gt; any {@code Environment} you have set in the MyBatis config file. This is
   * used only as a placeholder name. The default value is {@code SqlSessionFactoryBean.class.getSimpleName()}.
   *
   * @param environment
   *          the environment name
   */
  public void setEnvironment(String environment) {
<span class="fc" id="L457">    this.environment = environment;</span>
<span class="fc" id="L458">  }</span>

  /**
   * Set scripting language drivers.
   *
   * @param scriptingLanguageDrivers
   *          scripting language drivers
   *
   * @since 2.0.2
   */
  public void setScriptingLanguageDrivers(LanguageDriver... scriptingLanguageDrivers) {
<span class="fc" id="L469">    this.scriptingLanguageDrivers = scriptingLanguageDrivers;</span>
<span class="fc" id="L470">  }</span>

  /**
   * Set a default scripting language driver class.
   *
   * @param defaultScriptingLanguageDriver
   *          A default scripting language driver class
   *
   * @since 2.0.2
   */
  public void setDefaultScriptingLanguageDriver(Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver) {
<span class="fc" id="L481">    this.defaultScriptingLanguageDriver = defaultScriptingLanguageDriver;</span>
<span class="fc" id="L482">  }</span>

  /**
   * Add locations of MyBatis mapper files that are going to be merged into the {@code SqlSessionFactory} configuration
   * at runtime.
   * &lt;p&gt;
   * This is an alternative to specifying &quot;&amp;lt;sqlmapper&amp;gt;&quot; entries in an MyBatis config file. This property being
   * based on Spring's resource abstraction also allows for specifying resource patterns here: e.g.
   * &quot;classpath*:sqlmap/*-mapper.xml&quot;.
   *
   * @param mapperLocations
   *          location of MyBatis mapper files
   *
   * @see #setMapperLocations(Resource...)
   *
   * @since 3.0.2
   */
  public void addMapperLocations(Resource... mapperLocations) {
<span class="fc" id="L500">    setMapperLocations(appendArrays(this.mapperLocations, mapperLocations, Resource[]::new));</span>
<span class="fc" id="L501">  }</span>

  /**
   * Add type handlers.
   *
   * @param typeHandlers
   *          Type handler list
   *
   * @since 3.0.2
   */
  public void addTypeHandlers(TypeHandler&lt;?&gt;... typeHandlers) {
<span class="fc" id="L512">    setTypeHandlers(appendArrays(this.typeHandlers, typeHandlers, TypeHandler[]::new));</span>
<span class="fc" id="L513">  }</span>

  /**
   * Add scripting language drivers.
   *
   * @param scriptingLanguageDrivers
   *          scripting language drivers
   *
   * @since 3.0.2
   */
  public void addScriptingLanguageDrivers(LanguageDriver... scriptingLanguageDrivers) {
<span class="fc" id="L524">    setScriptingLanguageDrivers(</span>
<span class="fc" id="L525">        appendArrays(this.scriptingLanguageDrivers, scriptingLanguageDrivers, LanguageDriver[]::new));</span>
<span class="fc" id="L526">  }</span>

  /**
   * Add Mybatis plugins.
   *
   * @param plugins
   *          list of plugins
   *
   * @since 3.0.2
   */
  public void addPlugins(Interceptor... plugins) {
<span class="fc" id="L537">    setPlugins(appendArrays(this.plugins, plugins, Interceptor[]::new));</span>
<span class="fc" id="L538">  }</span>

  /**
   * Add type aliases.
   *
   * @param typeAliases
   *          Type aliases list
   *
   * @since 3.0.2
   */
  public void addTypeAliases(Class&lt;?&gt;... typeAliases) {
<span class="fc" id="L549">    setTypeAliases(appendArrays(this.typeAliases, typeAliases, Class[]::new));</span>
<span class="fc" id="L550">  }</span>

  private &lt;T&gt; T[] appendArrays(T[] oldArrays, T[] newArrays, IntFunction&lt;T[]&gt; generator) {
<span class="fc bfc" id="L553" title="All 2 branches covered.">    if (oldArrays == null) {</span>
<span class="fc" id="L554">      return newArrays;</span>
    }
<span class="fc bfc" id="L556" title="All 2 branches covered.">    if (newArrays == null) {</span>
<span class="fc" id="L557">      return oldArrays;</span>
    }
<span class="fc" id="L559">    List&lt;T&gt; newList = new ArrayList&lt;&gt;(Arrays.asList(oldArrays));</span>
<span class="fc" id="L560">    newList.addAll(Arrays.asList(newArrays));</span>
<span class="fc" id="L561">    return newList.toArray(generator.apply(0));</span>
  }

  @Override
  public void afterPropertiesSet() throws Exception {
<span class="fc" id="L566">    notNull(dataSource, &quot;Property 'dataSource' is required&quot;);</span>
<span class="fc" id="L567">    notNull(sqlSessionFactoryBuilder, &quot;Property 'sqlSessionFactoryBuilder' is required&quot;);</span>
    // TODO Review this statement as it seems off!
<span class="fc bfc" id="L569" title="All 8 branches covered.">    state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),</span>
        &quot;Property 'configuration' and 'configLocation' can not specified with together&quot;);

<span class="fc" id="L572">    this.sqlSessionFactory = buildSqlSessionFactory();</span>
<span class="fc" id="L573">  }</span>

  /**
   * Build a {@code SqlSessionFactory} instance.
   * &lt;p&gt;
   * The default implementation uses the standard MyBatis {@code XMLConfigBuilder} API to build a
   * {@code SqlSessionFactory} instance based on a Reader. Since 1.3.0, it can be specified a {@link Configuration}
   * instance directly(without config file).
   *
   * @return SqlSessionFactory
   *
   * @throws Exception
   *           if configuration is failed
   */
  protected SqlSessionFactory buildSqlSessionFactory() throws Exception {

    final Configuration targetConfiguration;

<span class="fc" id="L591">    XMLConfigBuilder xmlConfigBuilder = null;</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">    if (this.configuration != null) {</span>
<span class="fc" id="L593">      targetConfiguration = this.configuration;</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">      if (targetConfiguration.getVariables() == null) {</span>
<span class="fc" id="L595">        targetConfiguration.setVariables(this.configurationProperties);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">      } else if (this.configurationProperties != null) {</span>
<span class="fc" id="L597">        targetConfiguration.getVariables().putAll(this.configurationProperties);</span>
      }
<span class="fc bfc" id="L599" title="All 2 branches covered.">    } else if (this.configLocation != null) {</span>
<span class="fc" id="L600">      xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);</span>
<span class="fc" id="L601">      targetConfiguration = xmlConfigBuilder.getConfiguration();</span>
    } else {
<span class="fc" id="L603">      LOGGER.debug(</span>
<span class="nc" id="L604">          () -&gt; &quot;Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration&quot;);</span>
<span class="fc" id="L605">      targetConfiguration = new Configuration();</span>
<span class="fc" id="L606">      Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);</span>
    }

<span class="fc" id="L609">    Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);</span>
<span class="fc" id="L610">    Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);</span>
<span class="fc" id="L611">    Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);</span>

<span class="fc bfc" id="L613" title="All 2 branches covered.">    if (hasLength(this.typeAliasesPackage)) {</span>
<span class="fc" id="L614">      scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()</span>
<span class="fc bfc" id="L615" title="All 4 branches covered.">          .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">          .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);</span>
    }

<span class="fc bfc" id="L619" title="All 2 branches covered.">    if (!isEmpty(this.typeAliases)) {</span>
<span class="fc" id="L620">      Stream.of(this.typeAliases).forEach(typeAlias -&gt; {</span>
<span class="fc" id="L621">        targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span>
<span class="pc" id="L622">        LOGGER.debug(() -&gt; &quot;Registered type alias: '&quot; + typeAlias + &quot;'&quot;);</span>
<span class="fc" id="L623">      });</span>
    }

<span class="fc bfc" id="L626" title="All 2 branches covered.">    if (!isEmpty(this.plugins)) {</span>
<span class="fc" id="L627">      Stream.of(this.plugins).forEach(plugin -&gt; {</span>
<span class="fc" id="L628">        targetConfiguration.addInterceptor(plugin);</span>
<span class="pc" id="L629">        LOGGER.debug(() -&gt; &quot;Registered plugin: '&quot; + plugin + &quot;'&quot;);</span>
<span class="fc" id="L630">      });</span>
    }

<span class="fc bfc" id="L633" title="All 2 branches covered.">    if (hasLength(this.typeHandlersPackage)) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">      scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())</span>
<span class="pc bpc" id="L635" title="2 of 4 branches missed.">          .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))</span>
<span class="fc" id="L636">          .forEach(targetConfiguration.getTypeHandlerRegistry()::register);</span>
    }

<span class="fc bfc" id="L639" title="All 2 branches covered.">    if (!isEmpty(this.typeHandlers)) {</span>
<span class="fc" id="L640">      Stream.of(this.typeHandlers).forEach(typeHandler -&gt; {</span>
<span class="fc" id="L641">        targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span>
<span class="pc" id="L642">        LOGGER.debug(() -&gt; &quot;Registered type handler: '&quot; + typeHandler + &quot;'&quot;);</span>
<span class="fc" id="L643">      });</span>
    }

<span class="fc" id="L646">    targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);</span>

<span class="fc bfc" id="L648" title="All 2 branches covered.">    if (!isEmpty(this.scriptingLanguageDrivers)) {</span>
<span class="fc" id="L649">      Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -&gt; {</span>
<span class="fc" id="L650">        targetConfiguration.getLanguageRegistry().register(languageDriver);</span>
<span class="pc" id="L651">        LOGGER.debug(() -&gt; &quot;Registered scripting language driver: '&quot; + languageDriver + &quot;'&quot;);</span>
<span class="fc" id="L652">      });</span>
    }
<span class="fc" id="L654">    Optional.ofNullable(this.defaultScriptingLanguageDriver)</span>
<span class="fc" id="L655">        .ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span>

<span class="pc bpc" id="L657" title="1 of 2 branches missed.">    if (this.databaseIdProvider != null) {// fix #64 set databaseId before parse mapper xmls</span>
      try {
<span class="nc" id="L659">        targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));</span>
<span class="nc" id="L660">      } catch (SQLException e) {</span>
<span class="nc" id="L661">        throw new IOException(&quot;Failed getting a databaseId&quot;, e);</span>
<span class="nc" id="L662">      }</span>
    }

<span class="fc" id="L665">    Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);</span>

<span class="fc bfc" id="L667" title="All 2 branches covered.">    if (xmlConfigBuilder != null) {</span>
      try {
<span class="fc" id="L669">        xmlConfigBuilder.parse();</span>
<span class="pc" id="L670">        LOGGER.debug(() -&gt; &quot;Parsed configuration file: '&quot; + this.configLocation + &quot;'&quot;);</span>
<span class="nc" id="L671">      } catch (Exception ex) {</span>
<span class="nc" id="L672">        throw new IOException(&quot;Failed to parse config resource: &quot; + this.configLocation, ex);</span>
      } finally {
<span class="fc" id="L674">        ErrorContext.instance().reset();</span>
      }
    }

<span class="fc" id="L678">    targetConfiguration.setEnvironment(new Environment(this.environment,</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">        this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,</span>
        this.dataSource));

<span class="fc bfc" id="L682" title="All 2 branches covered.">    if (this.mapperLocations != null) {</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">      if (this.mapperLocations.length == 0) {</span>
<span class="fc" id="L684">        LOGGER.warn(() -&gt; &quot;Property 'mapperLocations' was specified but matching resources are not found.&quot;);</span>
      } else {
<span class="fc bfc" id="L686" title="All 2 branches covered.">        for (Resource mapperLocation : this.mapperLocations) {</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">          if (mapperLocation == null) {</span>
<span class="fc" id="L688">            continue;</span>
          }
          try {
<span class="fc" id="L691">            var xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(), targetConfiguration,</span>
<span class="fc" id="L692">                mapperLocation.toString(), targetConfiguration.getSqlFragments());</span>
<span class="fc" id="L693">            xmlMapperBuilder.parse();</span>
<span class="nc" id="L694">          } catch (Exception e) {</span>
<span class="nc" id="L695">            throw new IOException(&quot;Failed to parse mapping resource: '&quot; + mapperLocation + &quot;'&quot;, e);</span>
          } finally {
<span class="fc" id="L697">            ErrorContext.instance().reset();</span>
          }
<span class="pc" id="L699">          LOGGER.debug(() -&gt; &quot;Parsed mapper file: '&quot; + mapperLocation + &quot;'&quot;);</span>
        }
      }
    } else {
<span class="pc" id="L703">      LOGGER.debug(() -&gt; &quot;Property 'mapperLocations' was not specified.&quot;);</span>
    }

<span class="fc" id="L706">    return this.sqlSessionFactoryBuilder.build(targetConfiguration);</span>
  }

  @Override
  public SqlSessionFactory getObject() throws Exception {
<span class="fc bfc" id="L711" title="All 2 branches covered.">    if (this.sqlSessionFactory == null) {</span>
<span class="fc" id="L712">      afterPropertiesSet();</span>
    }

<span class="fc" id="L715">    return this.sqlSessionFactory;</span>
  }

  @Override
  public Class&lt;? extends SqlSessionFactory&gt; getObjectType() {
<span class="fc bfc" id="L720" title="All 2 branches covered.">    return this.sqlSessionFactory == null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();</span>
  }

  @Override
  public boolean isSingleton() {
<span class="fc" id="L725">    return true;</span>
  }

  @Override
  public void onApplicationEvent(ContextRefreshedEvent event) {
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">    if (failFast) {</span>
      // fail-fast -&gt; check all statements are completed
<span class="nc" id="L732">      this.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span>
    }
<span class="fc" id="L734">  }</span>

  private Set&lt;Class&lt;?&gt;&gt; scanClasses(String packagePatterns, Class&lt;?&gt; assignableType) throws IOException {
<span class="fc" id="L737">    Set&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L738">    var packagePatternArray = tokenizeToStringArray(packagePatterns,</span>
        ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
<span class="fc bfc" id="L740" title="All 2 branches covered.">    for (String packagePattern : packagePatternArray) {</span>
<span class="fc" id="L741">      var resources = RESOURCE_PATTERN_RESOLVER.getResources(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX</span>
<span class="fc" id="L742">          + ClassUtils.convertClassNameToResourcePath(packagePattern) + &quot;/**/*.class&quot;);</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">      for (Resource resource : resources) {</span>
        try {
<span class="fc" id="L745">          var classMetadata = METADATA_READER_FACTORY.getMetadataReader(resource).getClassMetadata();</span>
<span class="fc" id="L746">          Class&lt;?&gt; clazz = Resources.classForName(classMetadata.getClassName());</span>
<span class="fc bfc" id="L747" title="All 4 branches covered.">          if (assignableType == null || assignableType.isAssignableFrom(clazz)) {</span>
<span class="fc" id="L748">            classes.add(clazz);</span>
          }
<span class="nc" id="L750">        } catch (Throwable e) {</span>
<span class="nc" id="L751">          LOGGER.warn(() -&gt; &quot;Cannot load the '&quot; + resource + &quot;'. Cause by &quot; + e.toString());</span>
<span class="fc" id="L752">        }</span>
      }
    }
<span class="fc" id="L755">    return classes;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>